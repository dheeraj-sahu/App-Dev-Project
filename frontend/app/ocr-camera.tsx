import { Image } from "expo-image";
import * as ImagePicker from "expo-image-picker";
import { useCallback, useMemo, useState, useRef } from "react";
import { Platform, Pressable, StyleSheet, View } from "react-native";
import { Stack, useFocusEffect } from "expo-router";

import ParallaxScrollView from "@/components/parallax-scroll-view";
import { ThemedText } from "@/components/themed-text";
import { ThemedView } from "@/components/themed-view";

export default function OcrCameraScreen() {
    const [imageUri, setImageUri] = useState<string | null>(null);
    const [ocrText, setOcrText] = useState<string>("");
    const [isProcessing, setIsProcessing] = useState(false);
    const [errorMessage, setErrorMessage] = useState<string | null>(null);
    const hasOpenedRef = useRef(false);

    const canUseCamera = useMemo(() => Platform.OS !== "web", []);

    const runOcr = useCallback(async (uri: string) => {
        setIsProcessing(true);
        setErrorMessage(null);
        setOcrText("Processing image...");

        try {
            const formData = new FormData();
            console.log("uploading image")
            // In React Native, the 'file' object must look like this to upload via fetch:
            formData.append("file", {
                uri: uri,
                type: "image/jpeg", // Ensure this matches the extension
                name: "upload.jpg",
            } as any);

            formData.append("apikey", "K87899142388957");
            formData.append("language", "eng");
            // Adding isOverlayRequired helps see where text was found if needed
            formData.append("isOverlayRequired", "false");

            const response = await fetch("https://api.ocr.space/parse/image", {
                method: "POST",
                body: formData,
                headers: {
                    // DO NOT set 'Content-Type': 'multipart/form-data' manually.
                    // fetch will set it automatically with the correct boundary.
                },
            });

            const result = await response.json();

            if (result.OCRExitCode === 1 && result.ParsedResults) {
                const text = result.ParsedResults[0].ParsedText.trim();
                setOcrText(text || "Image uploaded, but no text was found.");
            } else {
                // API returned an error message in its own format
                setErrorMessage(result.ErrorMessage?.[0] || "OCR Server error.");
            }
        } catch (error) {
            console.error("OCR Error: ", error);
            setErrorMessage("Network error. Please check your internet connection.");
        } finally {
            setIsProcessing(false);
        }
    }, []);

    const captureImage = useCallback(async () => {
        setErrorMessage(null);

        if (!canUseCamera) {
            setErrorMessage("Camera is not available on web.");
            return;
        }

        const permission = await ImagePicker.requestCameraPermissionsAsync();
        if (!permission.granted) {
            setErrorMessage("Camera permission is required.");
            return;
        }

        const result = await ImagePicker.launchCameraAsync({
            quality: 0.8, // Reduced slightly for better performance
            allowsEditing: true, // Cropping helps OCR accuracy significantly
            aspect: [4, 3],
        });

        if (!result.canceled && result.assets?.[0]?.uri) {
            const uri = result.assets[0].uri;
            setImageUri(uri);
            // Small delay to allow UI to update before heavy OCR processing
            setTimeout(() => runOcr(uri), 500);
        }
    }, [canUseCamera, runOcr]);

    useFocusEffect(
        useCallback(() => {
            // Auto-open camera when screen is focused, but only if we haven't done it yet this session
            // and surely not if we already have an image.
            if (!hasOpenedRef.current && !imageUri) {
                hasOpenedRef.current = true;
                // Small delay to ensure transition animation finishes
                setTimeout(() => {
                    captureImage();
                }, 500);
            }
        }, [captureImage, imageUri])
    );

    return (
        <>
            <Stack.Screen options={{ title: "OCR Camera", headerBackTitle: "Back" }} />
            <ParallaxScrollView
                headerBackgroundColor={{ light: "#A1CEDC", dark: "#1D3D47" }}
                headerImage={
                    <View style={styles.headerContent}>
                        {imageUri ? (
                            <Image
                                source={{ uri: imageUri }}
                                style={styles.previewImage}
                                contentFit="contain"
                            />
                        ) : (
                            <View style={styles.placeholderHeader}>
                                <ThemedText>No Image Captured</ThemedText>
                            </View>
                        )}
                    </View>
                }
            >
                <ThemedView style={styles.titleContainer}>
                    <ThemedText type="title">Camera OCR</ThemedText>
                </ThemedView>

                <ThemedView style={styles.stepContainer}>
                    <Pressable
                        style={({ pressed }) => [
                            styles.captureButton,
                            pressed && styles.captureButtonPressed,
                            isProcessing && { backgroundColor: "#ccc" },
                        ]}
                        onPress={captureImage}
                        disabled={isProcessing}
                    >
                        <ThemedText type="defaultSemiBold" style={styles.captureButtonText}>
                            {isProcessing ? "Processing..." : "Take Photo"}
                        </ThemedText>
                    </Pressable>
                </ThemedView>

                <ThemedView style={styles.outputContainer}>
                    <ThemedText type="subtitle">Recognized text:</ThemedText>
                    {errorMessage ? (
                        <ThemedText style={styles.errorText}>{errorMessage}</ThemedText>
                    ) : (
                        <ThemedText style={styles.ocrResultText}>
                            {ocrText || "Result will appear here..."}
                        </ThemedText>
                    )}
                </ThemedView>
            </ParallaxScrollView>
        </>
    );
}

const styles = StyleSheet.create({
    titleContainer: {
        flexDirection: "row",
        alignItems: "center",
        gap: 8,
        marginBottom: 16,
    },
    stepContainer: { gap: 8, marginBottom: 16 },
    outputContainer: {
        gap: 8,
        padding: 10,
        backgroundColor: "rgba(0,0,0,0.05)",
        borderRadius: 8,
    },
    headerContent: {
        height: 220,
        width: "100%",
        alignItems: "center",
        justifyContent: "center",
    },
    previewImage: { height: "100%", width: "100%" },
    placeholderHeader: { height: 200, justifyContent: "center" },
    captureButton: {
        borderRadius: 12,
        backgroundColor: "#2F7CF6",
        paddingVertical: 16,
        alignItems: "center",
    },
    captureButtonPressed: { opacity: 0.8 },
    captureButtonText: { color: "#FFFFFF", fontSize: 18 },
    errorText: { color: "#D9534F" },
    ocrResultText: { fontSize: 16, lineHeight: 24 },
});
